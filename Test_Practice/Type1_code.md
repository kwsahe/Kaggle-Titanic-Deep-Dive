빅데이터 분석기사 실기 시험에서 데이터 전처리의 80%는 이 세 가지(`loc`, `iloc`, `isin`)로 해결됩니다. 헷갈리지 않게 **시험 실전용**으로 딱 정리해 드립니다.

-----

# ⚡️ Pandas 데이터 선택 3대장 완벽 정리

## 1\. 한눈에 비교 (vs)

| 구분 | **`loc`** (Label Location) | **`iloc`** (Integer Location) |
| :--- | :--- | :--- |
| **기준** | **이름(Label/Name)** | **순서(Index/Number)** |
| **행(Row)** | 인덱스 이름 (예: 'Row1') | 행 번호 (0, 1, 2...) |
| **열(Col)** | 컬럼 이름 (예: 'Age') | 열 번호 (0, 1, 2...) |
| **슬라이싱** | **끝번호 포함** (`['A':'C']` -\> A, B, C) | **끝번호 제외** (`[0:3]` -\> 0, 1, 2) |
| **주용도** | **조건 필터링**, 값 수정 | 데이터 분할, 순서 기반 추출 |

-----

## 2\. `loc`: "이름"과 "조건"으로 찾기 (가장 중요 ⭐)

시험에서 가장 많이 씁니다. **"조건에 맞는 데이터를 찾아 값을 바꿀 때"** 필수입니다.

### 📌 기본 문법

```python
# df.loc[행 조건(또는 이름), 열 이름]
```

### 🔥 실전 패턴 (무조건 외우기)

**① 조건으로 데이터 필터링 (행 선택)**

```python
# 나이가 30 이상인 사람만 뽑기
high_age = df.loc[df['Age'] >= 30]

# (추천) 사실 그냥 이렇게 더 많이 씁니다 (결과는 같음)
high_age = df[df['Age'] >= 30]
```

**② 특정 조건의 특정 컬럼만 뽑기 (행+열 선택)**

```python
# 성별이 'male'인 사람들의 'Age'만 뽑기
male_ages = df.loc[df['Sex'] == 'male', 'Age']
```

**③ ⭐ 조건부 값 변경 (결측치/이상치 처리의 핵심)**

```python
# 'Age'가 0보다 작은(이상치) 값을 0으로 변경
df.loc[df['Age'] < 0, 'Age'] = 0

# 'Grade'가 NaN인(결측치) 값을 'F'로 변경
df.loc[df['Grade'].isna(), 'Grade'] = 'F'
```

**④ 이름으로 슬라이싱 (끝 포함 주의\!)**

```python
# 컬럼 'A'부터 'C'까지 가져오기 ('C'도 포함됨!)
subset = df.loc[:, 'A':'C']
```

-----

## 3\. `iloc`: "숫자(순서)"로 찾기

데이터프레임의 컬럼 이름을 모르거나 무시하고, \*\*"위치"\*\*로만 자를 때 씁니다.

### 📌 기본 문법

```python
# df.iloc[행 번호, 열 번호]
```

### 🔥 실전 패턴

**① 데이터 분할 (Train/Test 나누기 또는 X/y 나누기)**

```python
# 맨 마지막 컬럼이 Target(y), 나머지가 Feature(X)일 때
X = df.iloc[:, :-1]  # 모든 행, 처음부터 마지막 컬럼 직전까지
y = df.iloc[:, -1]   # 모든 행, 맨 마지막 컬럼만
```

**② 특정 위치 데이터 확인**

```python
# 위에서 5개 행, 왼쪽에서 3개 열만 보기
print(df.iloc[:5, :3])

# 100번째 행 데이터 보기
print(df.iloc[99])
```

**③ 슬라이싱 (끝 제외 - 파이썬 리스트와 동일)**

```python
# 0번부터 2번까지 (3번은 포함 안 됨!)
subset = df.iloc[:, 0:3]
```

-----

## 4\. `isin`: "리스트"에 있는지 확인하기

여러 개의 조건(`OR`)을 걸 때 `|` 연산자를 여러 번 쓰는 대신 사용합니다. 코드가 훨씬 깔끔해집니다.

### 📌 기본 문법

```python
# df['컬럼'].isin([찾고_싶은_값_리스트])
```

### 🔥 실전 패턴

**① 여러 값 중 하나라도 포함되면 선택 (OR 조건)**

```python
# 도시가 'Seoul' 이거나 'Busan' 인 데이터 필터링
target_cities = ['Seoul', 'Busan']
result = df[df['City'].isin(target_cities)]

# (비교) isin 안 쓰면 이렇게 길어짐 (비추천)
# result = df[(df['City'] == 'Seoul') | (df['City'] == 'Busan')]
```

**② 포함되지 않는 것만 선택 (`~` 기호 사용)**

```python
# 도시가 'Seoul'이나 'Busan'이 아닌 나머지 지방 도시만 선택
result = df[~df['City'].isin(['Seoul', 'Busan'])]
```

-----

## 📝 시험장용 요약 치트시트

1.  **조건에 맞는 값을 바꾸고 싶다?** ➡️ 무조건 **`loc`**
      * `df.loc[조건, '컬럼'] = 새값`
2.  **마지막 컬럼만 따로 떼고 싶다?** ➡️ **`iloc`**
      * `X = df.iloc[:, :-1]`, `y = df.iloc[:, -1]`
3.  **"A거나 B거나 C인 것"을 찾고 싶다?** ➡️ **`isin`**
      * `df[df['col'].isin(['A', 'B', 'C'])]`

이 세 가지만 자유자재로 쓰시면 1유형 필터링 문제는 걱정 없습니다\!

# **📊 Pandas .str 메서드 정리 (문제별 활용)**
| 기능               | 메서드                                              | 설명                         | 사용 예시 (문제 상황)                                          |
| ---------------- | ------------------------------------------------ | -------------------------- | ------------------------------------------------------ |
| **부분 문자열 포함 여부** | `.str.contains("단어", case=False)`                | 특정 단어 포함 여부 (대소문자 무시 가능)   | 문제1: `"delivery"`가 remarks에 포함된 거래 찾기                  |
| **시작/끝 검사**      | `.str.startswith("단어")`, `.str.endswith("단어")`   | 특정 단어로 시작/끝나는지 확인          | remarks가 `"Fast"`로 시작하는 거래 찾기                          |
| **치환/변경**        | `.str.replace("기존","새로운")`                       | 문자열 일부를 다른 텍스트로 교체         | `"Refund"` → `"환불"` 바꾸기                                |
| **대소문자 변환**      | `.str.lower()`, `.str.upper()`, `.str.title()`   | 전부 소문자/대문자/첫 글자만 대문자 변환    | remarks 전처리 시 `"DELIVERY"` → `"delivery"`              |
| **공백 제거**        | `.str.strip()`, `.str.lstrip()`, `.str.rstrip()` | 앞뒤/왼쪽/오른쪽 공백 제거            | 데이터 클린징 단계에서 `"  Fast delivery "` 처리                   |
| **문자열 분리**       | `.str.split("구분자", expand=True)`                 | 문자열을 구분자로 나누기              | remarks `"Fast delivery"` → `"Fast"`, `"delivery"` 나누기 |
| **문자열 길이**       | `.str.len()`                                     | 문자열 길이 반환                  | remarks가 20자 이상인 거래만 추출                                |
| **정규표현식 추출**     | `.str.extract(r"(\d+)")`                         | 패턴(숫자, 문자 등) 추출            | remarks에서 `"15% 할인"` → `15` 숫자만 추출                     |
| **조건부 비율**       | `.str.contains("단어")` + `.mean()`                | 포함 비율 계산 (True=1, False=0) | `"service"`가 포함된 비율 구하기                                |

**📘 Pandas count, sum, size 차이**
| 함수          | 적용 대상             | 의미                | 특징                                                   | 외우기 팁                   |
| ----------- | ----------------- | ----------------- | ---------------------------------------------------- | ----------------------- |
| **count()** | Series/DataFrame  | **NaN 제외한 값의 개수** | Boolean Series에 쓰면 `True/False` 구분 안 하고 전체 개수를 반환    | **“결측 제외 개수”**          |
| **sum()**   | Series/DataFrame  | **합계**            | Boolean Series에 쓰면 `True=1, False=0`으로 처리 → 조건 만족 개수 | **“덧셈 (조건 충족 개수도 가능)”** |
| **size**    | DataFrame/GroupBy | **전체 행 개수**       | NaN 포함해서 그냥 “총 개수” 반환                                | **“사이즈=전체 길이”**         |

빅데이터 분석기사 실기 시험에서 \*\*`rank`(순위)\*\*와 \*\*`diff`(차이)\*\*는 데이터 전처리의 핵심 도구입니다.

시험장에서 헷갈리지 않도록 **필수 옵션**과 **주의사항** 위주로 딱 정리해 드립니다.

-----

# 🏆 1. `rank()` : 순위 구하기

데이터의 순서를 매길 때 사용합니다. 시험에서는 \*\*"동점자 처리(method)"\*\*와 **"오름차순/내림차순(ascending)"** 설정이 가장 중요합니다.

### 📌 기본 문법

```python
df['Rank'] = df['Column'].rank(method='...', ascending=...)
```

### 🔥 필수 파라미터 (시험용)

**1. `ascending` (정렬 기준)**

  * `True` (기본값): **작은 값**이 1등 (예: 달리기 기록, 불량률)
  * `False`: **큰 값**이 1등 (예: 점수, 매출액)

**2. `method` (동점자 처리 방식) ★★★**
값이 같을 때 등수를 어떻게 줄 것인가? (예: 100점, 100점, 90점)

| 옵션값 | 설명 | 결과 예시 | 비고 |
| :--- | :--- | :--- | :--- |
| **`'min'`** | **공동 등수** 부여 (가장 낮은 등수 기준) | **1등, 1등, 3등** | **시험 최빈출\!** (올림픽 방식) |
| `'dense'`| **공동 등수** 부여 (등수 건너뛰기 없음) | **1등, 1등, 2등** | 빽빽하게 채움 |
| `'first'`| **먼저 나온 데이터**가 상위 등수 | **1등, 2등, 3등** | 행 인덱스 순서대로 |
| `'average'`| 평균 등수 부여 (기본값) | 1.5등, 1.5등, 3등 | 시험에 잘 안 나옴 |

### 💻 실전 코드 예시

```python
# "매출액(Sales)이 높은 순서대로 순위를 매기되, 동점자는 같은 등수로 처리(1, 1, 3)하시오"
df['Rank'] = df['Sales'].rank(method='min', ascending=False)

# 상위 10등까지 필터링
top10 = df[df['Rank'] <= 10]
```

-----

# 📉 2. `diff()` : 차이 구하기 (시계열/변동폭)

\*\*"이전 행과의 차이"\*\*를 계산합니다. 매출 증감, 기온 변화, 주가 변동 등을 구할 때 필수입니다.

### 📌 기본 문법

```python
df['Diff'] = df['Column'].diff(periods=1)
```

### 🔥 치명적 주의사항 (시험용)

**1. 반드시 정렬(Sort) 먼저\!**

  * `diff`는 그냥 **"바로 윗줄"** 값을 뺍니다. 날짜나 순서가 뒤죽박죽이면 엉뚱한 값을 뺍니다.
  * 무조건 \*\*`sort_values()`\*\*를 먼저 해야 합니다.

**2. 그룹별 계산은 `groupby()`와 함께\!**

  * 여러 상품(Product)이 섞여 있을 때 그냥 `diff`를 하면, **A상품 마지막 날**과 **B상품 첫째 날**을 빼버립니다.
  * 반드시 **`df.groupby('Product')['Sales'].diff()`** 형식을 써야 합니다.

**3. 결측치(NaN) 발생**

  * 첫 번째 행은 이전 데이터가 없으므로 무조건 `NaN`이 됩니다. 계산 후 `dropna()` 처리가 필요할 수 있습니다.

### 💻 실전 코드 예시

**상황: "날짜별, 상품별 판매량 차이 구하기"**

```python
# 1. 정렬 (필수!) - 그룹 컬럼(상품), 시간 컬럼(날짜) 순으로
df = df.sort_values(by=['Product', 'Date'])

# 2. 그룹별 차이 계산
# (Product가 바뀔 때 엉뚱한 계산이 되지 않도록 groupby 사용)
df['Sales_Diff'] = df.groupby('Product')['Sales'].diff()

# 3. 절댓값 변환 (변동폭의 크기를 구할 때)
df['Abs_Diff'] = df['Sales_Diff'].abs()
```

-----

# ⚡️ 한 줄 요약표 (Cheat Sheet)

| 함수 | 목적 | 핵심 옵션 / 주의사항 | 코드 예시 |
| :--- | :--- | :--- | :--- |
| **`rank`** | **순위** | `method='min'` (1, 1, 3)<br>`ascending=False` (큰 게 1등) | `.rank(method='min', ascending=False)` |
| **`diff`** | **변화량** | **`sort_values` 선행 필수\!**<br>그룹별 계산 시 `groupby` 필수 | `.sort_values().groupby().diff()` |

이 두 가지만 확실히 구분하면 1유형의 "순위"나 "변동" 문제는 무조건 맞힐 수 있습니다\!
